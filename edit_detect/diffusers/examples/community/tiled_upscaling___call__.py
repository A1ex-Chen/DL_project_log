@torch.no_grad()
def __call__(self, prompt: Union[str, List[str]], image: Union[PIL.Image.
    Image, List[PIL.Image.Image]], num_inference_steps: int=75,
    guidance_scale: float=9.0, noise_level: int=50, negative_prompt:
    Optional[Union[str, List[str]]]=None, num_images_per_prompt: Optional[
    int]=1, eta: float=0.0, generator: Optional[torch.Generator]=None,
    latents: Optional[torch.Tensor]=None, callback: Optional[Callable[[int,
    int, torch.Tensor], None]]=None, callback_steps: int=1, tile_size: int=
    128, tile_border: int=32, original_image_slice: int=32):
    """
        Function invoked when calling the pipeline for generation.

        Args:
            prompt (`str` or `List[str]`):
                The prompt or prompts to guide the image generation.
            image (`PIL.Image.Image` or List[`PIL.Image.Image`] or `torch.Tensor`):
                `Image`, or tensor representing an image batch which will be upscaled. *
            num_inference_steps (`int`, *optional*, defaults to 50):
                The number of denoising steps. More denoising steps usually lead to a higher quality image at the
                expense of slower inference.
            guidance_scale (`float`, *optional*, defaults to 7.5):
                Guidance scale as defined in [Classifier-Free Diffusion Guidance](https://arxiv.org/abs/2207.12598).
                `guidance_scale` is defined as `w` of equation 2. of [Imagen
                Paper](https://arxiv.org/pdf/2205.11487.pdf). Guidance scale is enabled by setting `guidance_scale >
                1`. Higher guidance scale encourages to generate images that are closely linked to the text `prompt`,
                usually at the expense of lower image quality.
            negative_prompt (`str` or `List[str]`, *optional*):
                The prompt or prompts not to guide the image generation. Ignored when not using guidance (i.e., ignored
                if `guidance_scale` is less than `1`).
            num_images_per_prompt (`int`, *optional*, defaults to 1):
                The number of images to generate per prompt.
            eta (`float`, *optional*, defaults to 0.0):
                Corresponds to parameter eta (Î·) in the DDIM paper: https://arxiv.org/abs/2010.02502. Only applies to
                [`schedulers.DDIMScheduler`], will be ignored for others.
            generator (`torch.Generator`, *optional*):
                A [torch generator](https://pytorch.org/docs/stable/generated/torch.Generator.html) to make generation
                deterministic.
            latents (`torch.Tensor`, *optional*):
                Pre-generated noisy latents, sampled from a Gaussian distribution, to be used as inputs for image
                generation. Can be used to tweak the same generation with different prompts. If not provided, a latents
                tensor will ge generated by sampling using the supplied random `generator`.
            tile_size (`int`, *optional*):
                The size of the tiles. Too big can result in an OOM-error.
            tile_border (`int`, *optional*):
                The number of pixels around a tile to consider (bigger means less seams, too big can lead to an OOM-error).
            original_image_slice (`int`, *optional*):
                The amount of pixels of the original image to calculate with the current tile (bigger means more depth
                is preserved, less blur occurs in the final image, too big can lead to an OOM-error or loss in detail).
            callback (`Callable`, *optional*):
                A function that take a callback function with a single argument, a dict,
                that contains the (partially) processed image under "image",
                as well as the progress (0 to 1, where 1 is completed) under "progress".

        Returns: A PIL.Image that is 4 times larger than the original input image.

        """
    final_image = Image.new('RGB', (image.size[0] * 4, image.size[1] * 4))
    tcx = math.ceil(image.size[0] / tile_size)
    tcy = math.ceil(image.size[1] / tile_size)
    total_tile_count = tcx * tcy
    current_count = 0
    for y in range(tcy):
        for x in range(tcx):
            self._process_tile(original_image_slice, x, y, tile_size,
                tile_border, image, final_image, prompt=prompt,
                num_inference_steps=num_inference_steps, guidance_scale=
                guidance_scale, noise_level=noise_level, negative_prompt=
                negative_prompt, num_images_per_prompt=
                num_images_per_prompt, eta=eta, generator=generator,
                latents=latents)
            current_count += 1
            if callback is not None:
                callback({'progress': current_count / total_tile_count,
                    'image': final_image})
    return final_image
